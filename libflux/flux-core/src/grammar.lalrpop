use crate::{ast, ast::*, scanner::*, parser::strconv};

grammar;

extern {
    type Location = u32;
    type Error = String;

    enum Token {
        "identifier" => Token { tok: TokenType::Ident, .. },
        "string literal" => Token { tok: TokenType::String, .. },
        "int literal" => Token { tok: TokenType::Int, .. },
        "float literal" => Token { tok: TokenType::Float, .. },
        "duration literal" => Token { tok: TokenType::Duration, .. },
        "time literal" => Token { tok: TokenType::Time, .. },
        "regex literal" => Token { tok: TokenType::Regex, .. },

        "if" => Token { tok: TokenType::If, .. },
        "else" => Token { tok: TokenType::Else, .. },
        "then" => Token { tok: TokenType::Then, .. },
        "builtin" => Token { tok: TokenType::Builtin, .. },
        "package" => Token { tok: TokenType::Package, .. },
        "import" => Token { tok: TokenType::Import, .. },

        ":" => Token { tok: TokenType::Colon, .. },
        "," => Token { tok: TokenType::Comma, .. },
        "." => Token { tok: TokenType::Dot, .. },
        "=>" => Token { tok: TokenType::Arrow, .. },

        "=" => Token { tok: TokenType::Assign, .. },

        "+" => Token { tok: TokenType::Add, .. },
        "-" => Token { tok: TokenType::Sub, .. },
        "*" => Token { tok: TokenType::Mul, .. },
        "/" => Token { tok: TokenType::Div, .. },

        "==" => Token { tok: TokenType::Eq, .. },
        "!=" => Token { tok: TokenType::Neq, .. },
        "<=" => Token { tok: TokenType::Lte, .. },
        "<" => Token { tok: TokenType::Lt, .. },
        ">=" => Token { tok: TokenType::Gte, .. },
        ">" => Token { tok: TokenType::Gt, .. },
        "=~" => Token { tok: TokenType::RegexEq, .. },
        "!~" => Token { tok: TokenType::RegexNeq, .. },

        "{" => Token { tok: TokenType::LBrace, .. },
        "[" => Token { tok: TokenType::LBrack, .. },
        "(" => Token { tok: TokenType::LParen, .. },

        "}" => Token { tok: TokenType::RBrace, .. },
        "]" => Token { tok: TokenType::RBrack, .. },
        ")" => Token { tok: TokenType::RParen, .. },

        "EOF" => Token { tok: TokenType::Eof, .. },
    }
}

pub File: ast::File = {
    <package: Package?> <imports: Import*> <body: Body> <eof: Comments<"EOF">> => {
        ast::File {
            base: Default::default(),
            name: "".into(),
            package,
            imports,
            body,
            metadata: String::from("parser-type=lalrpop"),
            eof,
        }
    }
}

#[inline]
Comments<T>: Vec<Comment> = {
    T => <>.comments
}

Package: ast::PackageClause = {
    "package" <name: Identifier> => ast::PackageClause {
        base: Default::default(),
        name,
    }
}

Import: ast::ImportDeclaration = {
    "import" <alias: Identifier?> <path: StringLit> => ast::ImportDeclaration {
        base: Default::default(),
        alias,
        path,
    }
}

Body: Vec<Statement> = {
    <mut body: Body_<"expr">> => { body.reverse(); body }
}

Body_<EXPR>: Vec<Statement> = {
    => Vec::new(),

    <s: Statement<"">> <mut b: Body_<"expr">> => {
        b.push(s);
        b
    },

    <s: ExprStatement> <mut b: Body_<"">> if EXPR == "expr" => {
        b.push(s);
        b
    }
}

Statement<EXPR>: Statement = {
    <id: Identifier> "=" <init: Expression> => Statement::Variable(Box::new(VariableAssgn {
        base: Default::default(),
        id,
        init,
    })),

    <ExprStatement> if EXPR == "expr" => <>
}

ExprStatement: Statement = {
    <expression: ExpressionNoParen> => Statement::Expr(Box::new(ExprStmt {
        base: Default::default(),
        expression,
    })),
}

StringLit: StringLit = {
    <t: "string literal"> =>? {
        let value = strconv::parse_string(t.lit.as_str())
            .map_err(|err| err.to_string())?;
        Ok(StringLit {
            base: Default::default(),
            value,
        })
    }
}

Atom: Expression = {
    AtomOpt<"identifier", "paren">
}

AtomOpt<ID, PAREN>: Expression = {
    <Identifier> if ID == "identifier" => Expression::Identifier(<>),

    <object: AtomOpt<ID, PAREN>> "." <property: Identifier> => Expression::Member(Box::new(MemberExpr {
        base: Default::default(),
        lbrack: Default::default(),
        object,
        property: PropertyKey::Identifier(property),
        rbrack: Default::default(),
    })),

    <t: "int literal"> =>? Ok(Expression::Integer(IntegerLit {
        base: Default::default(),
        value: t.lit.parse::<i64>().map_err(|err| err.to_string())?,
    })),

    <t: "float literal"> =>? Ok(Expression::Float(FloatLit {
        base: Default::default(),
        value: t.lit.parse::<f64>().map_err(|err| err.to_string())?,
    })),

    <StringLit> => Expression::StringLit(<>),

    <t: "time literal"> =>? {
        let value = strconv::parse_time(t.lit.as_str())
            .map_err(|err| err.to_string())?;
        Ok(Expression::DateTime(DateTimeLit {
            base: Default::default(),
            value,
        }))
    },

    <t: "regex literal"> =>? {
        let value = strconv::parse_regex(t.lit.as_str())
            .map_err(|err| err.to_string())?;
        Ok(Expression::Regexp(RegexpLit {
            base: Default::default(),
            value,
        }))
    },

    <t: "duration literal"> =>? {
        let values = strconv::parse_duration(t.lit.as_str())
            .map_err(|err| err.to_string())?;
        Ok(Expression::Duration(DurationLit {
            base: Default::default(),
            values,
        }))
    },

    <lparen: Comments<"(">> <expression: Expression> <rparen: Comments<")">> if PAREN == "paren" => Expression::Paren(Box::new(ParenExpr {
        base: Default::default(),
        lparen,
        expression,
        rparen,
    })),

    <lbrack: "["> <elements: ArrayItems> <rbrack: "]"> => dbg!(Expression::Array(Box::new(ArrayExpr {
        lbrack: lbrack.comments,
        base: Default::default(),
        elements,
        rbrack: rbrack.comments,
    }))),

    <lbrace: Comments<"{">> <properties: CommaSep<Property>> <rbrace: Comments<"}">> => Expression::Object(Box::new(ObjectExpr {
        lbrace,
        base: Default::default(),
        with: None,
        properties,
        rbrace,
    })),
}

// ParenTail: () = {
//     <rparen: Comments<")">> => (),
//
//     <rparen: Comments<")">> "=>" => (),
// }

Expression: Expression = {
    ExpressionOpt<"identifier", "paren">
}

ExpressionNoParen: Expression = {
    ExpressionOpt<"identifier", "">
}

ExpressionOpt<ID, PAREN>: Expression = {
    AtomOpt<ID, PAREN>,

    <callee: AtomOpt<ID, PAREN>> <lparen: Comments<"(">>  <rparen: Comments<")">> if PAREN == "paren" => {
        Expression::Call(Box::new(CallExpr {
            base: Default::default(),
            callee,
            lparen,
            arguments: Vec::new(),
            rparen,
        }))
    },

    <left: AtomOpt<ID, PAREN>> "+" <right: Expression> => {
        Expression::Binary(Box::new(BinaryExpr {
            base: Default::default(),
            operator: Operator::AdditionOperator,
            left,
            right,
        }))
    },

    <left: AtomOpt<ID, PAREN>> "/" <right: Expression> => {
        Expression::Binary(Box::new(BinaryExpr {
            base: Default::default(),
            operator: Operator::DivisionOperator,
            left,
            right,
        }))
    }
}

PropertyItems: Vec<Property> = {
    => Vec::new(),

    <prop: Property> => {
        vec![prop]
    },

    <mut vec: PropertyItem+> <last: Property?> => {
        vec.extend(last);
        vec
    },
}

PropertyItem: Property = {
    <mut prop: Property> <comma: ","> => {
        prop.comma = comma.comments;
        prop
    },
}

PropertyKey: PropertyKey = {
    <Identifier> => PropertyKey::Identifier(<>),

    <StringLit> => PropertyKey::StringLit(<>),
}

Property: Property = {
    <key: PropertyKey> <prop: (Comments<":"> Expression)?> => {
        let (separator, value) = match prop {
            Some((s, v)) => (s, Some(v)),
            None => (Vec::new(), None),
        };
        Property {
            base: Default::default(),
            key,
            separator,
            value,
            comma: Vec::new(),
        }
    }
}

ArrayItems: Vec<ArrayItem> = {
    => dbg!(Vec::new()),

    <expression: Expression> => {
        vec![ArrayItem {
            expression,
            comma: Vec::new(),
        }]
    },

    <mut vec: ArrayItem+> <last: Expression?> => {
        vec.extend(last.map(|expression| ArrayItem {
            expression,
            comma: Vec::new(),
        }));
        vec
    },
}

ArrayItem: ArrayItem = {
    <expression: Expression> <comma: ","> => {
        ArrayItem {
            expression,
            comma: comma.comments,
        }
    },
}

Identifier: ast::Identifier = {
    <name: "identifier"> => ast::Identifier {
        base: Default::default(),
        name: name.lit,
    },
}


CommaSep<T>: Vec<T> = {
    => Vec::new(),

    <single: T> => {
        vec![single]
    },

    <mut vec: (<T> ",")+> <last: T?> => {
        vec.extend(last);
        vec
    },
}

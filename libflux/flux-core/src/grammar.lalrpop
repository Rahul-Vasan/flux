use crate::{ast, ast::*, scanner::*, parser::{strconv, binary_expr, SharedTokenizer, TokenizerMode}};

grammar(tokenizer: &SharedTokenizer<'_>);

extern {
    type Location = crate::scanner::Position;
    type Error = String;

    enum Token {
        "identifier" => Token { tok: TokenType::Ident, .. },
        "string literal" => Token { tok: TokenType::String, .. },
        "int literal" => Token { tok: TokenType::Int, .. },
        "float literal" => Token { tok: TokenType::Float, .. },
        "duration literal" => Token { tok: TokenType::Duration, .. },
        "time literal" => Token { tok: TokenType::Time, .. },
        "regex literal" => Token { tok: TokenType::Regex, .. },

        "\"" => Token { tok: TokenType::Quote, .. },
        "string expr" => Token { tok: TokenType::StringExpr, .. },
        "text" => Token { tok: TokenType::Text, .. },

        "if" => Token { tok: TokenType::If, .. },
        "else" => Token { tok: TokenType::Else, .. },
        "then" => Token { tok: TokenType::Then, .. },
        "builtin" => Token { tok: TokenType::Builtin, .. },
        "package" => Token { tok: TokenType::Package, .. },
        "import" => Token { tok: TokenType::Import, .. },

        "<-" => Token { tok: TokenType::PipeReceive, .. },
        "|>" => Token { tok: TokenType::PipeForward, .. },

        ":" => Token { tok: TokenType::Colon, .. },
        "," => Token { tok: TokenType::Comma, .. },
        "." => Token { tok: TokenType::Dot, .. },
        "=>" => Token { tok: TokenType::Arrow, .. },

        "=" => Token { tok: TokenType::Assign, .. },

        "exists" => Token { tok: TokenType::Exists, .. },

        "+" => Token { tok: TokenType::Add, .. },
        "-" => Token { tok: TokenType::Sub, .. },
        "*" => Token { tok: TokenType::Mul, .. },
        "/" => Token { tok: TokenType::Div, .. },
        "%" => Token { tok: TokenType::Mod, .. },
        "^" => Token { tok: TokenType::Pow, .. },

        "==" => Token { tok: TokenType::Eq, .. },
        "!=" => Token { tok: TokenType::Neq, .. },
        "<=" => Token { tok: TokenType::Lte, .. },
        "<" => Token { tok: TokenType::Lt, .. },
        ">=" => Token { tok: TokenType::Gte, .. },
        ">" => Token { tok: TokenType::Gt, .. },
        "=~" => Token { tok: TokenType::RegexEq, .. },
        "!~" => Token { tok: TokenType::RegexNeq, .. },

        "and" => Token { tok: TokenType::And, .. },
        "or" => Token { tok: TokenType::Or, .. },

        "{" => Token { tok: TokenType::LBrace, .. },
        "[" => Token { tok: TokenType::LBrack, .. },
        "(" => Token { tok: TokenType::LParen, .. },

        "}" => Token { tok: TokenType::RBrace, .. },
        "]" => Token { tok: TokenType::RBrack, .. },
        ")" => Token { tok: TokenType::RParen, .. },

        "EOF" => Token { tok: TokenType::Eof, .. },
    }
}

pub File: ast::File = {
    <package: Package?> <imports: Import*> <body: Body> <eof: Comments<"EOF">> => {
        ast::File {
            base: Default::default(),
            name: "".into(),
            package,
            imports,
            body,
            metadata: String::from("parser-type=lalrpop"),
            eof,
        }
    }
}

#[inline]
Comments<T>: Vec<Comment> = {
    T => <>.comments
}

Package: ast::PackageClause = {
    "package" <name: Identifier> => ast::PackageClause {
        base: Default::default(),
        name,
    }
}

Import: ast::ImportDeclaration = {
    "import" <alias: Identifier?> <path: StringLit> => ast::ImportDeclaration {
        base: Default::default(),
        alias,
        path,
    }
}

Body: Vec<Statement> = {
     <first: ExprStatement<"identifier", "paren">?> <mut body: Body_<"">> => {
         body.extend(first);
         body.reverse();
         body
    }
}

Body_<EXPR>: Vec<Statement> = {
    => Vec::new(),

    <s: Statement<"">> <mut b: Body_<"expr">> => {
        dbg!("asd");
        b.push(s);
        b
    },

    <s: ExprStatement<"identifier", "">> <mut b: Body_<"expr">> if EXPR == "expr" => {
        dbg!("2");
        b.push(s);
        b
    }
}

Statement<EXPR>: Statement = {
    <id: Identifier> "=" <init: Expression> => Statement::Variable(Box::new(VariableAssgn {
        base: Default::default(),
        id,
        init,
    })),

    <ExprStatement<"identifier", "">> if EXPR == "expr" => <>
}

ExprStatement<ID, PAREN>: Statement = {
    <expression: ExpressionOpt<ID, PAREN>> => Statement::Expr(Box::new(ExprStmt {
        base: Default::default(),
        expression,
    })),
}

Block: Block = {
    <lbrace: Comments<"{">> <body: Body_<"">> <rbrace: Comments<"}">> => {
        Block {
            base: Default::default(),
            lbrace,
            body,
            rbrace,
        }
    }
}

StringLit: StringLit = {
    <t: "string literal"> =>? {
        let value = strconv::parse_string(t.lit.as_str())
            .map_err(|err| err.to_string())?;
        Ok(StringLit {
            base: Default::default(),
            value,
        })
    }
}

DefaultMode: () = {
    => tokenizer.set_mode(TokenizerMode::Default),
}

RegexMode: () = {
    => tokenizer.set_mode(TokenizerMode::Regex),
}

StringExprMode: () = {
    => tokenizer.set_mode(TokenizerMode::StringExpr),
}

Atom: Expression = {
    AtomOpt<"identifier", "paren">
}

AtomOpt<ID, PAREN>: Expression = {
    <Identifier> if ID == "identifier" => Expression::Identifier(<>),

    "<-" => Expression::PipeLit(PipeLit {
        base: Default::default(),
    }),

    <object: AtomOpt<ID, PAREN>> "." <property: Identifier> => Expression::Member(Box::new(MemberExpr {
        base: Default::default(),
        lbrack: Default::default(),
        object,
        property: PropertyKey::Identifier(property),
        rbrack: Default::default(),
    })),

    <t: "int literal"> =>? Ok(Expression::Integer(IntegerLit {
        base: Default::default(),
        value: t.lit.parse::<i64>().map_err(|err| err.to_string())?,
    })),

    <t: "float literal"> =>? Ok(Expression::Float(FloatLit {
        base: Default::default(),
        value: t.lit.parse::<f64>().map_err(|err| err.to_string())?,
    })),

    <StringLit> => Expression::StringLit(<>),


    StringExpr,

    <t: "time literal"> =>? {
        let value = strconv::parse_time(t.lit.as_str())
            .map_err(|err| err.to_string())?;
        Ok(Expression::DateTime(DateTimeLit {
            base: Default::default(),
            value,
        }))
    },

    <t: "regex literal"> =>? {
        let value = strconv::parse_regex(t.lit.as_str())
            .map_err(|err| err.to_string())?;
        Ok(Expression::Regexp(RegexpLit {
            base: Default::default(),
            value,
        }))
    },

    <t: "duration literal"> =>? {
        let values = strconv::parse_duration(t.lit.as_str())
            .map_err(|err| err.to_string())?;
        Ok(Expression::Duration(DurationLit {
            base: Default::default(),
            values,
        }))
    },

    <lparen: Comments<"(">> <expression: ExpressionOpt<"", "paren">> <rparen: Comments<")">> if PAREN == "paren" => Expression::Paren(Box::new(ParenExpr {
        base: Default::default(),
        lparen,
        expression,
        rparen,
    })),

    ArrayOrDict if PAREN == "paren",

    <lbrace: Comments<"{">> <properties: CommaSep<Property>> <rbrace: Comments<"}">> => Expression::Object(Box::new(ObjectExpr {
        lbrace,
        base: Default::default(),
        with: None,
        properties,
        rbrace,
    })),
}

ArrayOrDict: Expression = {
    <lbrack: "["> <elements: ArrayItems> <rbrack: "]"> => Expression::Array(Box::new(ArrayExpr {
        lbrack: lbrack.comments,
        base: Default::default(),
        elements,
        rbrack: rbrack.comments,
    })),

    <lbrack: "["> ":" <rbrack: "]"> => {
        Expression::Dict(Box::new(DictExpr {
            lbrack: lbrack.comments,
            base: Default::default(),
            elements: Vec::new(),
            rbrack: rbrack.comments,
        }))
    },
    <lbrack: "["> <key: Expression> <elements: ":"> <val: Expression> <rest: ("," <DictItems>)?> <rbrack: "]"> => {
        let mut elements = vec![DictItem { key, val, comma: Default::default() }];
        elements.extend(rest.into_iter().flatten());
        Expression::Dict(Box::new(DictExpr {
            lbrack: lbrack.comments,
            base: Default::default(),
            elements,
            rbrack: rbrack.comments,
        }))
    }
}

DictItems: Vec<DictItem> = {

    <prop: DictItem_> => {
        vec![prop]
    },

    <mut vec: DictItem+> <last: DictItem_?> => {
        vec.extend(last);
        vec
    },
}

DictItem: DictItem = {
    <mut dict: DictItem_> <comma: Comments<",">> => {
        dict.comma = comma;
        dict
    },
}

DictItem_: DictItem = {
    <key: Expression> ":" <val: Expression> => {
        DictItem {
            key,
            val,
            comma: Default::default(),
        }
    },
}

StringExpr: Expression = {
    StringExprStart <StringExprTail>
}

StringExprStart: () = {
    "\"" StringExprMode,
}

StringExprTail: Expression = {
    StringExprMode <parts: StringExprPart*> "\"" RegexMode => Expression::StringExpr(Box::new(StringExpr {
        base: Default::default(),
        parts,
    })),
}

StringExprPart: StringExprPart = {
    "string expr" <expression: Expression> "}" =>  StringExprPart::Interpolated(InterpolatedPart {
        base: Default::default(),
        expression,
    }),
    "text" =>? {
        let value = strconv::parse_text(<>.lit.as_str())?;
        Ok(StringExprPart::Text(TextPart {
            base: Default::default(),
            value,
        }))
    },
}

FunctionBody: FunctionBody = {
   // Block => FunctionBody::Block(<>),
   Expression => FunctionBody::Expr(<>),
}

FunctionParam: Property = {
    <key: Identifier> <value: ("=" <Expression>)?> => {
        Property {
            base: Default::default(),
            key: key.into(),
            separator: Vec::new(),
            value,
            comma: Vec::new(),
        }
    }
}

// ParenTail: () = {
//     <rparen: Comments<")">> => (),
//
//     <rparen: Comments<")">> "=>" => (),
// }

CallExpr<ID, PAREN>: Expression = {
    AtomOpt<ID, PAREN>,

    "exists" <argument: AtomOpt<ID, PAREN>> if PAREN == "paren" => Expression::Unary(Box::new(UnaryExpr {
        base: Default::default(),
        operator: Operator::ExistsOperator,
        argument,
    })),

    "+" <argument: AtomOpt<ID, PAREN>> if PAREN == "paren" => Expression::Unary(Box::new(UnaryExpr {
        base: Default::default(),
        operator: Operator::AdditionOperator,
        argument,
    })),

    "-" <argument: AtomOpt<ID, PAREN>> if PAREN == "paren" => Expression::Unary(Box::new(UnaryExpr {
        base: Default::default(),
        operator: Operator::SubtractionOperator,
        argument,
    })),

    <array: AtomOpt<ID, PAREN>> <lbrack: Comments<"[">> <index: Expression> <rbrack: Comments<"]">> => {
        Expression::Index(Box::new(IndexExpr {
            base: Default::default(),
            array,
            lbrack,
            index,
            rbrack,
        }))
    },

    CallExpr_<ID, PAREN> => Expression::Call(Box::new(<>)),
}


CallExpr_<ID, PAREN>: CallExpr = {
    <callee: AtomOpt<ID, PAREN>> <lparen: Comments<"(">> <arguments: CommaSep<Property>> <rparen: Comments<")">> => {
        CallExpr {
            base: Default::default(),
            callee,
            lparen,
            arguments: vec![Expression::Object(Box::new(ObjectExpr {
                base: Default::default(),
                lbrace: vec![],
                with: None,
                properties: arguments,
                rbrace: vec![],
            }))],
            rparen,
        }
    },
}

PipeExpr<ID, PAREN>: Expression = {
    CallExpr<ID, PAREN>,

    <argument: PipeExpr<ID, PAREN>> "|>" <call: CallExpr_<"identifier", "paren">> =>
        Expression::PipeExpr(Box::new(PipeExpr {
            base: Default::default(),
            argument,
            call,
        })),
}

PowExpr<ID, PAREN>: Expression = {
    PipeExpr<ID, PAREN>,

    <PowExpr<ID, PAREN>> <"^"> <PipeExpr<"identifier", "paren">> => binary_expr(<>),
}

MulExpr<ID, PAREN>: Expression = {
    PowExpr<ID, PAREN>,

    <MulExpr<ID, PAREN>> <"*"> <PowExpr<"identifier", "paren">> => binary_expr(<>),
    <MulExpr<ID, PAREN>> <"/"> <PowExpr<"identifier", "paren">> => binary_expr(<>),
    <MulExpr<ID, PAREN>> <"%"> <PowExpr<"identifier", "paren">> => binary_expr(<>),
}

AddExpr<ID, PAREN>: Expression = {
    MulExpr<ID, PAREN>,

    <AddExpr<ID, PAREN>> <"+"> <MulExpr<"identifier", "paren">> => binary_expr(<>),
    <AddExpr<ID, PAREN>> <"-"> <MulExpr<"identifier", "paren">> => binary_expr(<>),
}

CmpExpr<ID, PAREN>: Expression = {
    AddExpr<ID, PAREN>,

    <CmpExpr<ID, PAREN>> <"=="> <AddExpr<"identifier", "paren">> => binary_expr(<>),
    <CmpExpr<ID, PAREN>> <"!="> <AddExpr<"identifier", "paren">> => binary_expr(<>),
    <CmpExpr<ID, PAREN>> <"<"> <AddExpr<"identifier", "paren">> => binary_expr(<>),
    <CmpExpr<ID, PAREN>> <"<="> <AddExpr<"identifier", "paren">> => binary_expr(<>),
    <CmpExpr<ID, PAREN>> <">"> <AddExpr<"identifier", "paren">> => binary_expr(<>),
    <CmpExpr<ID, PAREN>> <">="> <AddExpr<"identifier", "paren">> => binary_expr(<>),
    <CmpExpr<ID, PAREN>> <"=~"> <AddExpr<"identifier", "paren">> => binary_expr(<>),
    <CmpExpr<ID, PAREN>> <"!~"> <AddExpr<"identifier", "paren">> => binary_expr(<>),
}

AndExpr<ID, PAREN>: Expression = {
    CmpExpr<ID, PAREN>,

    <AndExpr<ID, PAREN>> <"and"> <CmpExpr<"identifier", "paren">> => binary_expr(<>),
}

Expression: Expression = {
    ExpressionOpt<"identifier", "paren">
}

ExpressionNoParen: Expression = {
    ExpressionOpt<"identifier", "">
}

ExpressionOpt<ID, PAREN>: Expression = {
    <AndExpr<ID, PAREN>>,
    <AndExpr<ID, PAREN>> <"or"> <Expression> => binary_expr(<>),

    <lparen: Comments<"(">> <params: CommaSep<FunctionParam>> <rparen: Comments<")">>
        <arrow: Comments<"=>">> <body: FunctionBody> if PAREN == "paren" =>
    {
        Expression::Function(Box::new(FunctionExpr {
            base: Default::default(),
            lparen,
            params,
            rparen,
            arrow,
            body,
        }))
    },

    <tk_if: Comments<"if">> <test: Expression>
        <tk_then: Comments<"then">> <consequent: Expression>
        <tk_else: Comments<"else">> <alternate: Expression> =>
    {
        Expression::Conditional(Box::new(ConditionalExpr {
            base: Default::default(),
            tk_if,
            test,
            tk_then,
            consequent,
            tk_else,
            alternate,
        }))
    }
}

PropertyItems: Vec<Property> = {
    => Vec::new(),

    <prop: Property> => {
        vec![prop]
    },

    <mut vec: PropertyItem+> <last: Property?> => {
        vec.extend(last);
        vec
    },
}

PropertyItem: Property = {
    <mut prop: Property> <comma: ","> => {
        prop.comma = comma.comments;
        prop
    },
}

PropertyKey: PropertyKey = {
    <Identifier> => PropertyKey::Identifier(<>),

    <StringLit> => PropertyKey::StringLit(<>),
}

Property: Property = {
    <key: PropertyKey> <prop: (Comments<":"> Expression)?> => {
        let (separator, value) = match prop {
            Some((s, v)) => (s, Some(v)),
            None => (Vec::new(), None),
        };
        Property {
            base: Default::default(),
            key,
            separator,
            value,
            comma: Vec::new(),
        }
    }
}

ArrayItems: Vec<ArrayItem> = {
    => Vec::new(),

    <expression: Expression> => {
        vec![ArrayItem {
            expression,
            comma: Vec::new(),
        }]
    },

    <mut vec: ArrayItem+> <last: Expression?> => {
        vec.extend(last.map(|expression| ArrayItem {
            expression,
            comma: Vec::new(),
        }));
        vec
    },
}

ArrayItem: ArrayItem = {
    <expression: Expression> <comma: ","> => {
        ArrayItem {
            expression,
            comma: comma.comments,
        }
    },
}

Identifier: ast::Identifier = {
    <name: "identifier"> => ast::Identifier {
        base: Default::default(),
        name: name.lit,
    },
}


CommaSep<T>: Vec<T> = {
    => Vec::new(),

    <single: T> => {
        vec![single]
    },

    <mut vec: (<T> ",")+> <last: T?> => {
        vec.extend(last);
        vec
    },
}
